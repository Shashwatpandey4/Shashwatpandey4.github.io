---
layout: post
title: "Getting Started with MLIR Toy Tutorial - Chapter 1"
date: 2025-01-22
type: Worklog
abstract: "Rewriting the MLIR TOy tutorial, in a more simpler and intuitive way."
tags: [MLIR, Compilers, LLVM]
author: "Shashwat Pandey"
description: "Rewriting the MLIR Toy tutorial, in a more simpler and intuitive way."
image : 
  path : /images/mlir.png

---



While reading the MLIR tutorial, and I found it was a bit hard to understand. So I decided to rewrite it in a more simpler and intuitive way. Starting from the setup and then understanding the components along the way.

Let's start with the setup.

On the Getting Started page, has the following steps (since i use a linux machine, i'm following the Unix-like compile/testing step):

```bash

git clone https://github.com/llvm/llvm-project.git
mkdir llvm-project/build
cd llvm-project/build
cmake -G Ninja ../llvm \
   -DLLVM_ENABLE_PROJECTS=mlir \
   -DLLVM_BUILD_EXAMPLES=ON \
   -DLLVM_TARGETS_TO_BUILD="Native;NVPTX;AMDGPU" \
   -DCMAKE_BUILD_TYPE=Release \
   -DLLVM_ENABLE_ASSERTIONS=ON \
   -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DLLVM_ENABLE_LLD=ON

cmake --build . --target check-mlir

```

First create an empty directory for the project, and then clone the llvm-project repository into it.

```bash
git clone https://github.com/llvm/llvm-project.git
```

Then create a build directory and navigate into it.

```bash
mkdir llvm-project/build
cd llvm-project/build
```

now we need to configure the build system.

### before that, let's first understands what is a build system.

While working with compiled languages, we use a compiler to convert our c/cpp or other languages into machine code. The compiler works on single source file at a time. 

But when we have multiple source files, we need to compile them all together. This is where the build system comes in.

A build system is a tool that helps us compile multiple source files together. It also helps us manage dependencies between files, and it also helps us to compile the code in a way that is optimized for the target architecture.

so MLIR use cmake ninja to build the project.

### Why cmake and ninja?

CMake and Ninja serve different roles, and using both together offers some benefits.

- **CMake** is a build system generator. It doesn't actually build the code; rather, it generates build files for other tools to use. It can generate files for various build systems (like Makefiles, Visual Studio project files, or Ninja build files). It's responsible for managing complex build configurations, handling dependencies, and ensuring that the project structure is correctly set up.

- **Ninja** is a fast build system. It takes the build files (such as the ones generated by CMake) and actually performs the work of compiling and linking the code. Ninja is optimized for speed and is particularly efficient in handling incremental builds (only rebuilding what's changed, rather than the entire project).

So, **CMake** is used to configure the project, and **Ninja** is used to build it quickly. Using CMake with Ninja combines the flexibility of CMake's configuration capabilities with Ninja's speed and efficiency for actual building.


Now let's go back to the setup.

```bash
cmake -G Ninja ../llvm \
   -DLLVM_ENABLE_PROJECTS=mlir \
   -DLLVM_BUILD_EXAMPLES=ON \
   -DLLVM_TARGETS_TO_BUILD="Native;NVPTX;AMDGPU" \
   -DCMAKE_BUILD_TYPE=Release \
   -DLLVM_ENABLE_ASSERTIONS=ON \
   -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DLLVM_ENABLE_LLD=ON
```

let's break down the command.

- `-G Ninja` : This specifies the generator to use. In this case, it's Ninja, which is a fast build system.

- `../llvm` : This is the path to the LLVM source code. The `..` indicates that the build system should look for the LLVM source code in the parent directory of the current directory.

- `-DLLVM_ENABLE_PROJECTS=mlir` : This enables the MLIR project within the LLVM build system.

- `-DLLVM_BUILD_EXAMPLES=ON` : This enables the building of example code, which can be useful for learning and testing.

- `-DLLVM_TARGETS_TO_BUILD="Native"` : This specifies the targets to build. In this case, it's building for the native architecture, since we are not utilising our GPU, it's building for our CPU architecture. (mine is x86_64)

- `-DCMAKE_BUILD_TYPE=Release` : Builds an optimized version of the code

- `-DLLVM_ENABLE_ASSERTIONS=ON` : Adds extra checks to help catch bugs

- `-DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DLLVM_ENABLE_LLD=ON` : This sets the C and C++ compilers to clang and clang++, and enables LLD (LLVM Linker Driver) for faster linking.

Now since we have configured the build system, we can build the project.

```bash
cmake --build . --target check-mlir
```

This command builds and tests MLIR to make sure everything is working correctly. The `--target check-mlir` part tells CMake specifically what we want to build and test.

Now we have built the project, and the tutorial is about building a compiler for a toy language. So let's first describe the Toy language.

It only defines a tensor data structure, in the tensor the data is stored in the form of double precision floating point numbers. so you can define a any kind of tensor upto 2 dimensions.

i.e. scalar, vector, and 2D matrix. No 3D tensors or higher dimensions are supported.

so let's simple start by defining variables. 

first let's create our toy language file. 
goto `llvm-project/mlir/examples/toy/Ch1/` and create a file named `sample.toy`.

toy uses main function as it's entry point. so let's define a main function.

```
def main(){
var a = 5;                     
var b<1,1> = [1];                
var c<1,2> = [1, 2];              
var d = [[1, 2], [3, 4]];         
var e<3,2> = [1, 2, 3, 4, 5, 6];  
var f<3,3> = [1, 2, 3, 4, 5, 6, 7, 8, 9]; 

}
```

here we have defined the variables `a`, `b`, `c`, `d`, `e`, `f`, with different dimensions. if you are wondering why some variable have dimensions as `<x,y>`, this is called a flat syntax. so basically it's a way to define the dimensions of the tensor, and you can do it either way.

### now let's view it's AST(Abstract Syntax Tree).

to do that we run the following command.

```
./bin/toyc-ch1 ../mlir/examples/toy/Ch1/ast.toy -emit=ast
```

let's understand what this command does.

- `./bin/toyc-ch1` : This is the path to the toy compiler.
- `../mlir/examples/toy/Ch1/sample.toy` : This is the path to the toy language file.
- `-emit=ast` : This tells the compiler to emit the AST of the toy language file.

After running the command, you will see the AST of the toy language file in the terminal.

```bash
  Module:
    Function 
      Proto 'main' @../mlir/examples/toy/Ch1/sample.toy:1:1
      Params: []
      Block {
        VarDecl a<> @../mlir/examples/toy/Ch1/sample.toy:2:1
          5.000000e+00 @../mlir/examples/toy/Ch1/sample.toy:2:9
        VarDecl b<1, 1> @../mlir/examples/toy/Ch1/sample.toy:3:1
          Literal: <1>[ 1.000000e+00] @../mlir/examples/toy/Ch1/sample.toy:3:14
        VarDecl c<1, 2> @../mlir/examples/toy/Ch1/sample.toy:4:1
          Literal: <2>[ 1.000000e+00, 2.000000e+00] @../mlir/examples/toy/Ch1/sample.toy:4:14
        VarDecl d<> @../mlir/examples/toy/Ch1/sample.toy:5:1
          Literal: <2, 2>[ <2>[ 1.000000e+00, 2.000000e+00], <2>[ 3.000000e+00, 4.000000e+00]] @../mlir/examples/toy/Ch1/sample.toy:5:9
        VarDecl e<3, 2> @../mlir/examples/toy/Ch1/sample.toy:6:1
          Literal: <6>[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00] @../mlir/examples/toy/Ch1/sample.toy:6:14
        VarDecl f<3, 3> @../mlir/examples/toy/Ch1/sample.toy:7:1
          Literal: <9>[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00, 7.000000e+00, 8.000000e+00, 9.000000e+00] @../mlir/examples/toy/Ch1/sample.toy:7:14
      } // Block

```

yes it's a bit hard to understand, but it's just a tree structure of the toy language file. 
let's understand it's components.

![AST](/images/sample_ast1.png)

- `Module` : This is the root of the AST. It contains all the functions in the toy language file.
- `Function` : This is the function definition. It contains the name of the function, the parameters, and the block of code.
- `Proto` : This is the prototype of the function. It contains the name of the function, the parameters, and the return type.
- `Params` : This is the parameters of the function. It contains the parameters of the function.
- `VarDecl` : This is the variable declaration. It contains the name of the variable, the dimensions, and the value of the variable.
- `Literal` : This is the literal value of the variable. It contains the value of the variable.
- `Block` : This is the block of code. It contains the statements in the function.


let's see how this AST will change when we add a new funtion and perform some operations on the variables.

modifief sample.toy file : 

```bash
def main(){
           
var d = [[1, 2], [3, 4]];         
var e<3,2> = [1, 2, 3, 4, 5, 6];  



var g = multiply_transpose(d, e);

}

def multiply_transpose(a, b) {
  return transpose(a) * transpose(b);
}
```
new AST :

```bash
  Module:
    Function 
      Proto 'main' @../mlir/examples/toy/Ch1/sample.toy:1:1
      Params: []
      Block {
        VarDecl d<> @../mlir/examples/toy/Ch1/sample.toy:3:1
          Literal: <2, 2>[ <2>[ 1.000000e+00, 2.000000e+00], <2>[ 3.000000e+00, 4.000000e+00]] @../mlir/examples/toy/Ch1/sample.toy:3:9
        VarDecl e<3, 2> @../mlir/examples/toy/Ch1/sample.toy:4:1
          Literal: <6>[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00] @../mlir/examples/toy/Ch1/sample.toy:4:14
        VarDecl g<> @../mlir/examples/toy/Ch1/sample.toy:8:1
          Call 'multiply_transpose' [ @../mlir/examples/toy/Ch1/sample.toy:8:9
            var: d @../mlir/examples/toy/Ch1/sample.toy:8:28
            var: e @../mlir/examples/toy/Ch1/sample.toy:8:31
          ]
      } // Block
    Function 
      Proto 'multiply_transpose' @../mlir/examples/toy/Ch1/sample.toy:12:1
      Params: [a, b]
      Block {
        Return
          BinOp: * @../mlir/examples/toy/Ch1/sample.toy:13:25
            Call 'transpose' [ @../mlir/examples/toy/Ch1/sample.toy:13:10
              var: a @../mlir/examples/toy/Ch1/sample.toy:13:20
            ]
            Call 'transpose' [ @../mlir/examples/toy/Ch1/sample.toy:13:25
              var: b @../mlir/examples/toy/Ch1/sample.toy:13:35
            ]
      } // Block
```

![AST](/images/sample_ast2.png)

here we can see that the AST has changed.

- `VarDecl g` : This is the variable declaration for the variable g.
- `Call` : This is the call to the function.
- `Call 'multiply_transpose'` : This is the call to the multiply_transpose function.
- `Call 'transpose'` : This is the call to the transpose function.
- `BinOp: *` : This is the binary operation for the multiplication.

so the newer part of the AST defines the multiply_transpose function, which takes two parameters a and b, and returns the result of the multiplication of the transpose of a and b.

The Toy language has only 2 built-in functions, `transpose` and `print`, also supports basic math operations like multiplication.

Type System of the Toy language :

- It has Static type checking, which means that the type of the variable is known at compile time. 
- Type inference meaning that the type of the variable is inferred from the context.


### This was the front end of the compiler. what we didn't implement is the lexer and parser.

Lexer is the part of the compiler that converts the source code into tokens. For example, the source code `var a = 5;` will be converted into the tokens `var`, `a`, `=`, `5`, `;`.

Parser is the part of the compiler that converts the tokens into an AST. For example, the tokens `var`, `a`, `=`, `5`, `;` will be converted into the AST `VarDecl a<> @../mlir/examples/toy/Ch1/sample.toy:2:1 5.000000e+00 @../mlir/examples/toy/Ch1/sample.toy:2:9`.

you can view the lexer and parser implementation in the `examples/toy/Ch1/include/toy/Lexer.h` & `examples/toy/Ch1/include/toy/Parser.h` files.

So till now the flow is source code -> lexer -> tokens -> parser -> AST.

![Frontend](/images/frontend.png)


In the next chapter we will learn how to convert AST into MLIR.




